#### Linux中的常用命令

##### sed命令

###### 定义

+ sed是一种几乎可以应用在所有Unix和Linux平台上的轻量级编辑器，体积小。所以，他可以对从管道这样的标准输入中接收数据进行编辑

###### 操作

+ `sed [option]  'action'  file`命令来使用sed

+ 相关参数

  + `-n`：一般sed命令会把所有的数据都输出到屏幕上，如果加入这个选项就只会把经过sed命令处理的行输出到屏幕上

    ```shell
    # 只输出第二行的数据
    sed -n 2p student.txt 
    ```

  + `-e`:允许对输入的数据应用多条sed命令

    ```shell
    # 执行多行命令，把第三行的112替换成224，同时把第二行的56替换成128
    sed -e '3s/112/224/g; 2s/56/128/g'
    ```

  + `-f脚本文件名`:从sed脚本中读入sed操作，和awk命令的-f相似

  + `-r`:支持正则表达是

  + `-i`:用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出动作

    ```shell 
    # 把第二行的数据修改为no such person输出
    sed -i '2c no such person' student.txt
    ```

  + `a\`：追加，在当前行后添加一行或者多行。当添加多行时需要在每行的末尾加上`\`表示数据未完结

    ```shell
    # 在第二行后面追加hello
    sed ’2a hello' student.txt
    ```

  + `c\`：替换，用c后面的字符串替换原始数据行。当替换多行时，除最后一行外，每行末尾的结束需要加上`\`表示数未完结

    ```shell 
    # 将第二行的数据替换成world
    sed  -n  2p '2c world' student.txt
    ```

  + `i\`:插入，在当前行前插入一行或者多行。插入多行时和`a\`的用法一样

    ```shell 
    # 在第二行之前插入hello world
    sed '2i hello world' student.txt
    ```

  + `d`：删除指定的行

    ```shell 
    # 删除第二行到第四行
    sed '2, 4d' student.txt
    # 删除第二行到最后一行
    sed '2, $d' student.txt
    ```

  + `p`：打印，输出指定的行

    ```shell
    # 输出第2行
    sed -n 2p student.txt
    ```

  + `s`：字符串替换

    ```shell 
    # 将第一行的xxx替换成yyy
    sed '1s/xxx/yyy/g' student.txt
    ```

+ 补充：

  + sed命令所做的修改并不会直接改变文件的内容(如果是用管道符接收命令的输出，连文件都没有)，而是把修改的结果显示到屏幕上，除非使用-i才会直接修改文件

##### tr命令

###### 定义

+ tr主要用于将从标准输入读取的数据进行结果集映射、字符压缩和字符删除。它首先会将标准输入按照某种方式进行排序，然后进行换行，再根据给出的命令行参数做相关处理

###### 操作

+ `tr [option] [set1] [set2]`来执行命令

+ 相关参数

  + 一般情况下的使用

    ```shell
    # 将ls输出的结果，把c字符替换成空格后，再进行换行
    ls | tr 'c' '\t'
    ```

  + `-s`:压缩字符

    ```shell
    # 将ls输出的结果，对含有空格的进行压缩，压缩之后再进行换行
    ls | tr -s ' '
    # 如果有集合set2，一般是进行替换
    # 对含有空格的字符替换-之后进行换行
    ls | tr -s ' '  '-'
    ```

  + `-d`:删除字符

    ```shell
    # -d 后面只能跟一个字符集
    # 删除空格之后进行换行
    ls | tr -d " "
    ```

  + `-c`：使用`set1`的补集

    ```shell
    # 对set1的补集进行替换，一般set2是一个字符，如果set2是多个字符只会使用最后一个字符
    # 将”123“的补集替换成d之后再进行换行
    ls | tr -c "123" "d"
    ```

    ```shell
    # 一般情况下是-d 与 -c 配合使用，即先查找出来set1的补集，然后再进行删除
    # 对输入的数据，查找“123”的补集，然后删除，再执行换行
    # cat student.txt | tr -d -c "123"
    ```

  + `-t`:截断set1,使得set1的长度与set2的长度相同

+ tr可以使用的几种字符

  + | 字符       | 含义                                                       |
    | ---------- | ---------------------------------------------------------- |
    | [:alnum:]  | 所有的数字和字母                                           |
    | [:alpha:]  | 所有的字母                                                 |
    | [:blank:]  | 所有的水平空白，包括空格和tab                              |
    | [:cntrl:]  | 所有控制字符（非打印字符）                                 |
    | [:digit:]  | 所有数字                                                   |
    | [:graph:]  | 所有的打印字符                                             |
    | [:lower:]  | 所有的小写字母                                             |
    | [:print:]  | 所有的打印字符=数字+字母+标点+空格                         |
    | [:punct:]  | 所有标点符号                                               |
    | [:space:]  | 所有的水平或垂直空白=空格+tab+分行符+垂直tab+分页符+回车键 |
    | [:upper;]  | 所有大写字母                                               |
    | [:xdigit:] | 所有十六进制数                                             |

##### sort命令

###### 定义

+ sort可针对文本内容，以行为单位来排序

###### 语法

+ `sort [option] file.`

###### 相关参数

+ -n:按照字符串数值排序，与-g区别为不转为浮点数

  ```shell
  # 按照数值进行排序
  sort -n num.txt
  ```

+ -g:按通用数值排序，支持科学计数法

  ```shell 
  sort -g num.txt
  ```

+ -k:排序从pos1开始，若指定pos2，则pos2结束，否则以pos1排序。

  ```shell 
  # -t指定分隔符，-k表示第几列，-r指定是升序还是降序
  # 对文件file使用分隔符：从第三列降序排序
  sort -t ':' -k 3 -nr file
  ```

+ -t:指定列的分隔符

+ -r:降序排序，默认升序

+ -h:使用易读性数字

+ -u:去除重复行

  ```shell 
  # 对文件Word.txt进行去重后排序
  sort -u word.txt
  ```

+ -o:将输出写入文件

  ```shell 
  # 在shell中，一般将控制台内容写入文件可以使用重定向，但如果想要把sort排序内容写回文件，则不能使用重定向。
  # 需要使用-o参数
  # 对sort文件进行排序后再写回到word.txt
  sort word.txt -o word.txt
  ```

  

#### awk命令

##### 定义

+ awk是一种编程语言，用于Linux/Unix下对文本和数据进行处理。数据可以来自标准输入，一个或多个文件，或其他命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是Linux/Unix下的一个强大的编程工具。它在命令行中使用，但是更多是作为脚本来使用。awk有很多内建功能，比如数组，函数等，这是它和c语言的相同之处，灵活性是awk的最大优势

##### 操作

###### 语法格式

+ `awk [option] 'script'  var=value file(s)`
+ `awk [option]  -f  scriptfile var=value file(s)`

###### 常用命令

+ `-F fs`:fs指定输入分隔符，fs可以是字符串或正则表达式
+ `-v var=value`:赋值一个用户定义变量，将外部变量传递给awk
+ `-f scriptfile`:从脚本文件中读取awk命令

##### awk脚本

###### 定义

+ awk脚本是由模式和操作组成

###### 模式和操作

+ 模式可以是以下任意一种：
  + 正则表达式：使用通配符的扩展集
  + 关系表达式：使用运算符进行操作，可以是字符串或数字的比较
  + 模式匹配表达式：用`~`（匹配）和`~!`不匹配
  + BEGIN语句块，pattern语句块，END语句块
+ 操作由一个或者多个命令、函数、表达式组成，之间由换行符或者分号分开，并位于大括号内，主要部分是：变量或数组赋值、输出命令，内置函数，控制流语句

###### awk脚本基本格式

+ awk 'BEGIN{ commands }	pattern{ commands } 	END{ commands }' file

+ > 一个awk脚本通常是由BEGIN，通用语句块，END语句块组成，三部分都是可选的。脚本通常是被单引号或双引号包住

+ ```shell 
  awk 'BEGIN{ i=0 }	{ i++ }	END{ print i }'
  awk "BEGIN{ i=0 }	{ i++ }	END{ print i}"
  ```

##### awk执行过程

+ 第一步：执行`BEGIN {commands} pattern`语句块中的语句

+ > BEGIN语句块：在awk开始从输入输出流中读取行之前执行，在BEGIN语句块中执行变量初始化，打印输表头等操作

+ 第二步：从文件或标准输入中读取一行，然后执行`pattern{ commands }`语句块。它逐行扫描文件从第一行到最后一行重复这个过程直到全部文件被读取

+ > pattern语句块：pattern语句块通用的命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{print}，即打印一个读取到的行。`{ }`类似一个循环体，会对文件找那个的每一行进行迭代，通常将变量初始化语句放到BEGIN语句块中，将打印结果等语句放到END语句中

+ 第三步：当读至输入流末尾时，执行`END { commands }`语句块

+ > END语句块：在awk从输入流中读取完所有的行之后执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它是一个可选的语句块

##### AWK内置变量

+ $n:当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段
+ $0:这个变量包含执行过程中当前文本内容
+ ARGC命令行参数的数目
+ ARGV:包含命令行参数的数组
+ ARGING:命令行中当前文件的位置
+ CONVFMT:数字转换格式(默认值为%.6g)
+ ENVIRON:环境边浪关联数组
+ ERRNO:最后一个系统错误描述
+ FIELDWIDTHS:字段宽度列表(用空格键分隔)
+ FILENAME:当前输入文件的名
+ NR:表示记录数，在执行过程中对应当前的行号
+ FNR:同NR表示当前文件
+ FS:字段分隔符（默认是任何空格）
+ IGNORECASE:如果是真，则进行忽略大小写匹配
+ NF:表示字段数，在执行的过程中对应于当前字段数。`print $NF`对应一行中最后一个字段
+ OFMT:数字的输出格式(默认值是%.6g)
+ OFS:输出字段分隔符(默认是一个空格)
+ ORS:输出记录分隔符:(默认是一个换行符)
+ RS:记录分隔符(默认是一个换行符)
+ RSTART:由match函数所匹配的字符串的第一个位置
+ RLENGTH:由match函数所匹配的字符串的长度

#### 其他命令

| 命令       | 作用                                        |
| ---------- | ------------------------------------------- |
| !!         | 执行上一次的命令                            |
| ！[a-z]    | 执行以某个首字母开头的命令                  |
| history    | 查看历史内容                                |
| &          | 后台执行                                    |
| ${file#/}  | 拿掉第一条/及其左边的字符，输出后面的内容   |
| ${file##/} | 拿掉最后一条/及其左边的字符，输出后面的内容 |









