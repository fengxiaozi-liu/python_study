@classmethod
def cls_method(cls):
	print('这是一个类方法')
@staticmethod
def jtff():
	print('这是一个静态方法')

调用类方法可以是
	类名.cls_method
	对象名.cls_method
调用实例方法
	类名.实例方法(第一参数是传递任意一个对象名,参数)
	对象名.实例方法
调用静态方法
	类和对象都能够直接调用
生成项目文档的操作
	python -m pydoc -b 模块名
	python -m pydoc -w  模块名
	python -m pydoc -p 模块名要指定端口号




私有化属性
	_变量名  让一个变量变成受保护的变量，只能在当前的模块中使用，一旦导入就会失效
	__变量名， 完成变量的私有化，目的是为了不让别人可以修改，私有化的属性的内部原理是，重写了变量名
	原有的变量名变成了_类名__变量名
私有化方法
	__方法名 也是python内部重写了方法的名称，

property装饰器
	property的作用是让用户可以调用属性的方式调用方法
	下面一般接三种方法
	@property
	def age(self):
		return self._age
	@ age.setter
	def set_age(self,age):
		self._age = age

	@age.deleter
	def del_age(self):
		del self._age

类内置的属性
	__dict__  返回类中的所有属性和方法
	__base__ 返回当前类所继承的父类
	__doc__   返回类的说明解释文档
	__module__ 返回类定义所在的模块

对象的内置属性
	__dict__ 返回当前对象，所具有的属性
	__class__ 返回当前对象，是由哪一个类创建的

类中的内置方法
	__init__方法
		在通过类创建一个具体的对象的时候就会调用这个方法，来完成具体对象的创建
	__str__/__repr__  
		这两个方法都是在你指向这个类，但是不创建实例对象的时候会自动的调用 
		Person就直接调用了这个方法， 当你执行Person()的时候就调用了这个方法
		并且这个方法的内部只能返回一个字符串
	__call__
		当你创建出来一个具体的对象之后，不是使用p.方法名，而是使用p()的形式就会调用类里面的call方法


python中的生命周期
	生命周期指的是一个对象从诞生到消亡的过程
	监听对象的生命周期会用到下面三个方法
	__new__
		当我们在创建一个对象的时候，这个方法就会帮我们在内部找到一块内存，来存放我们的独享
	__init__
		当我们在创建一个对象的时候，这个方法会帮我我们附加一些信息在里面
	__del__ 
		当我们在删除一个对象的时候，这个方法就会自动的执行，帮我们把对象删除

python中的内存管理机制
	可以将数据分为可变数据类型和不可变数据类型
		不可变数据类型是：
			数字，字符串，他们在内存中有这指定的好的空间
			a=1, b=1, 1这个地址是不变的，a和b都执行了统一块内存空间
		可变数据类型
			列表，元组，字典， 集合， 对象都是可变的数据类型
			a = [1,2,3], b=[1,2,3] 即使他们两个列表有着相同的数据，他们也指向不同的空间
	获取内存地址的操作
		id(变量名) 获取十进制变量的地址
		hex(变量名) 获取十六进制的地址
	垃圾回收
		简单回收
			当一个对对象的别名被销毁或者是对象的别名指向了别的地址块之后，就会删除这个对象的引用
		对于循环引用的回收
			一个对象在经历过几次释放仍然存在，那么就怀疑他是循环引用
			那么就对所有的容器对象找到他所引用的对象，并减去1，如果减去1之后变成0，我们就确定他是循环引用
			可以删除
		为了减少判断的失误，使用了分代回收机制，分为0代，1代和2代

python中类的继承
	类的继承就是一个类对另一个类的资源有使用权
	继承分类
		单继承
		多继承
	继承形态
		单继承
		无重叠的多继承
		有重叠的多继承
	继承的原则
		记住是按照c3算法原则，从上到下，从左到右
	资源的覆盖/重写
		优先级高的类写了一个和优先级低的类相同的属性和方法会优先调用优先级高的类的方法
		这就是资源的覆盖或者资源的重写
	资源的累加
		就是子类在父类的基础上增加了额外的额外的属性和方法
		def __init__(self,arg1,arg2,arg3)
			super(类名,self).__init__(arg1,arg2)
			self.arg3 = arg3
			super的第一个参数是查找谁的下一个节点，第二个参数是按照谁的orm链条去查找
			在子类的init方法中一定要有和父类一样的参数，然后再增加新的参数
		def foo(self, arg):
			super().foo()
			return xxxx
		 	在继承父类的方法中要写一个类，并写要有返回值

python中的多态
	就是一个子类继承父类实现不同的功能的过程就是多态

python中的设计原则
	solid原则
	




	
	
	