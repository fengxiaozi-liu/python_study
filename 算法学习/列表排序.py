"""
lowb三人组：冒泡排序，选择排序，插入排序
冒泡排序：
    列表相邻的数，如果前面的比后面的大，则交换两个数
    一趟排序完成后，无须区减少一个数，有序区增加一个数
    时间复杂度是o(n^2)
选择排序：
    一趟排序记录最小的数，放到第一个位置
    再一趟排序记录列表无序区最小的数，放到第二个位置
    .....
    算法的关键点：有序区，无序区，无序区最小数的位置
插入排序：
    时间复杂度是o(n^2)

总结：
    做排序一定将列表分为无须区和有序区
    冒泡排序：
        冒泡排序是将相邻的两个元素进行比较，每次从无须区拿出最小或者最大的那个数放在有序区
        冒泡排序小技巧：如果在一次循环中没有出现交换的元素我们就认为它已经是有序的了，我们就跳出循环，不在排序
    选择排序
        选择排序是假定无须区最左边的元素是最小或者最大的数，然后遍历后面的无序区，如果出现了比假定更小或者更大的数
        我们就交换这两个元素的位置
    插入排序
        让指针先指向有序区最右边的位置，然后遍历无序区，如果出现了比有序区小或者大的数，我们就将有序区指针指向的那个数向
        右移动一格位置，然后再将那个小或者大的数插入到有序区指针指向的那个位置，然后让有序区的指针向左移动，继续去和这个小
        或者大的数比较，直到有序区出现比这个数小或者大的数，或者是指针指向了最左边，我们就停止循环

niub三人组：
快速排序(我将它称为二分排序)：
    思路：
        1.去一个元素p(第一个元素),使元素p归为
        2.列表被p分为两部分，左边的都比p小，右边的都比p大 ---归为
        3.重复进行上面的二个步骤
    准备：
        快速排序需要一个归为函数来实现归为
        怎么实现归位呢：
            选定最左边的数为中间的那个数，这里记为temp
            再确定两个指针，分别指向最左边和最右边
            从右边选出来比temp小的数，从左边选出来比temp大的数
            等到两个指针重合后，我们认为已经达到中间位置，这时把temp放到中间就可以
            这样就实现了归位即左边的数都比temp小，右边的数都比temp大
    快速排序的时间复杂度是o(nlogn),快速排序的最坏情况是选择了最小或者最大的数，那么其时间复杂度是o(n^2)
    可以随机选择出来第一个数和第一个数进行交换
堆排序
    准备：
        树与二叉树
        树是一种数据结构
        树是一种可以递归定义的数据结构
        树是由n个节点组合成的集合
        如果n=0，那么他就是一个空树
        如果n>0，那存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树
        树的概念：
            根节点，叶子节点
            树的深度(高度)
            树的度：最大节点的那个度
            孩子节点/父节点
            子树
        二叉树
            二叉树的分类：
                满二叉树
                    每一个节点的度都是2
                完全二叉树
                    叶子节点只能出现在最下层或者次下层，并且最下面一层的节点都集中在该层做左边的若干位置
            二叉树的存储方式(表示方式)：
                链式存储方式
                顺序存储方式：就是用列表来存储
                    用列表存储后父节点和孩子节点的下标有什么关系
                        左孩子节点：i -->2i + 1 左孩子节点的下标一定是奇数
                        右孩子节点：i -->2i + 2 右孩子节点的下标是不为0的偶数
        堆是什么：
            定义：
                堆是一种特殊的完全二叉树
            分类：
                大根堆：一棵完全二叉树，满足任一节点都比其他孩子节点大
                小根堆：一棵完全二叉树，满足任一节点逗比其他孩子节点小
            性质：
                向下调整性质
                假设根节点的左右子树都是堆，但根节点不满足堆性质
                可以通过一次向下调整来将其变成一个堆
    堆排序的过程
        1.建立堆
            先调整最后一个有叶子节点的父节点
        2.得到堆顶元素，为最大元素
        3.去掉堆顶元素，将最后一个元素放到堆顶，此时可通过一次调整重新使堆排序
        4.堆顶元素为第二大元素
        5.重复步骤3，知道堆变空


"""


# ====================================lowb三人组排序===============================================

# # 冒泡排序
# # 改进：如果一趟循环中没有发生交换我们就认为他已经是有序的
# def bubble_sort(li):
#     print('冒泡排序')
#     for i in range(len(li) - 1):
#         exchange = False
#         for j in range(len(li) - i - 1):
#             if li[j] > li[j + 1]:
#                 exchange = True
#                 li[j], li[j + 1] = li[j + 1], li[j]
#         print(li)
#         if not exchange:
#             break
#     return li
#
#
# # 选择排序
# def select_sort_simple(li):
#     new_li = []
#     for i in range(len(li)):
#         min_val = min(li)  # 这里也出现了一次循环，min排序时间复杂度是o(n)
#         li.remove(min_val)
#         new_li.append(min_val)  # remove的时间复杂度也是o(n)的
#     return new_li
#
#
# # 改进的选择排序
# def select_sort(li):
#     print('选择排序')
#     for i in range(len(li) - 1):
#         min_loc = i  # 最小值设定为无须区的最左边的位置
#         for j in range(i + 1, len(li)):
#             if li[j] < li[min_loc]:
#                 min_loc = j
#         li[i], li[min_loc] = li[min_loc], li[i]
#         print(li)
#     return li
#
#
# # 插入排序
# def insert_sort(li):
#     print('插入排序')
#     for i in range(1, len(li)):
#         temp = li[i]   # 注意： 一定要将抽出的牌临时存储起来，因为下面的排序会更改列表中的数值
#         j = i - 1
#         # 进行替换的条件是排序区还没有和抽出来的牌比较，并别排序区有牌比无排序区的值大
#         while j >= 0 and li[j] > temp:
#             li[j + 1] = li[j]  # 让排序区的牌向右移动一格
#             j -= 1   # 然后再指向左边的排序区
#         li[j+1] = temp
#         print(li)
#     return li
#
#
# li = [3, 5, 2, 6, 4, 7, 9]
# la = [3, 5, 2, 6, 4, 7, 9]
# lb = [3, 5, 2, 6, 4, 7, 9]
# # 测试冒泡排序
# print(bubble_sort(li))
# # 测试选择排序
# print(select_sort(la))
# # 测试插入排序
# print(insert_sort(lb))

# ========================================niub三人组排序方式==================================

# 快速排序-需要一个partition函数来实现归位
# def partition(li, left, right):
#     """
#     一个归为函数，让选定的那个数，左边的值都比他小，右边的值都比他大
#     :param li: 传递的一个列表
#     :param left: 左边的指针
#     :param right: 右边的指针
#     :return:
#     """
#     temp = li[left]
#     while left < right:  # 终止循环的条件就是当两个指针重合的时候
#         while li[right] >= temp and left < right:  # 从右边查找比temp小的数，直到找到那个数，不然指针一直左移
#             right -= 1
#         li[left] = li[right]  # 找到后将右边的值给左边
#         while li[left] < temp and left < right:  # 从左边找比temp大的数，如果没有找到则则指针一直右移
#             left += 1
#         li[right] = li[left]  # 将左边的值给右边
#     li[left] = temp  # 将最初的temp放在两指针相交的位置
#     return left
#
#
# def quick_sort(li, left, right):
#     """
#     快速排序函数
#     :param li: 传入进来的一个列表
#     :param left: 最左面的指针
#     :param right: 最右边的指针
#     :return: 一个有序列表
#     """
#     if left < right:
#         mid = partition(li, left, right)
#         quick_sort(li, left, mid - 1)
#         quick_sort(li, mid + 1, right)
#     return li
#
#
# lc = [5, 7, 4, 6, 3, 8, 22, 1, 2, 10, 9, 8]
# print(partition(lc, 0, len(lc) - 1))
# print(quick_sort(lc, 0, len(lc) - 1))

# 堆排序
